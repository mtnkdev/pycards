\documentclass[12pt, titlepage]{article}
\usepackage{booktabs}
\usepackage{tabularx}
\usepackage{hyperref}

\hypersetup{
	colorlinks,
	citecolor=black,
	filecolor=black,
	linkcolor=black,
	urlcolor=blue
}
\usepackage[round]{natbib}
\title{SE 3XA3: Test Plan\\PyCards}
\author{Team 2
	\\ Aravi Premachandran  premaa
	\\ Michael Lee  leemr2
	\\ Nikhil Patel  patelna2
}
\date{\today}

\begin{document}
	\maketitle
	\pagenumbering{roman}
	\tableofcontents
	\listoftables
	\listoffigures
	\begin{table}[bp]
		\caption{\bf Revision History}
		\begin{tabularx}{\textwidth}{p{3cm}p{2cm}X}
			\toprule {\bf Date} & {\bf Version} & {\bf Notes}\\
			\midrule
			October 27 & 0.1 & Rough Draft\\
			\bottomrule
		\end{tabularx}
	\end{table}
	\newpage
	\pagenumbering{arabic}
	\section{General Information}
	\subsection{Purpose}
	\indent \indent The purpose of conducting testing is twofold. While testing 
	cannot prove correctness or the absence of bugs, it can be useful for 
	finding instances of incorrect behaviour. By ensuring that testing is done 
	in a traceable and repeatable manner (namely through automation), defects 
	that are uncovered can be traced, isolated, and addressed. With automation, 
	testing can be performed throughout the life cycle of the product with very 
	little overhead.\par
	The other reason for conducting testing is to demonstrate to the 
	client	that our product is reliable, robust and meets the requirements 
	that were set forth (using fit criterion or some other measure of degree
	of fulfilment).
	\subsection{Scope}
	\indent\indent PyCards is a collection of card games implemented as a 
	desktop application. As with any software program, it is important that it 
	undergoes various iterations of testing throughout its product lifecyle.
	Our development team is using a number of different test types, including 
	functional, structural, and unit tests, static and dynamic, manual as well 
	as automated.
	While automated testing is largely preferred for reasons such as greater 
	traceability, reproducibility, and efficiency, testing will also need to be 
	done manually, especially for validating non-functional requirements.
	Thus, the scope of testing for this product includes functional, 
	structural, and unit tests, static and dynamic testing, and manual and 
	automated testing.
	
	\subsection{Acronyms, Abbreviations, and Symbols}
	
	\begin{table}[hbp]
		\caption{\textbf{Table of Abbreviations}} \label{AbbrTable}
		\begin{tabularx}{\textwidth}{p{3cm}X}
			\toprule
			\textbf{Abbreviation} & \textbf{Definition} \\
			\midrule
			Abbreviation1 & Definition1\\
			Abbreviation2 & Definition2\\
			\bottomrule
		\end{tabularx}
	\end{table}
	\begin{table}[!htbp]
		\caption{\textbf{Table of Definitions}} \label{DefTable}
		\begin{tabularx}{\textwidth}{p{3cm}X}
			\toprule
			\textbf{Term} & \textbf{Definition}\\
			\midrule
			Widget & A functional component of a graphical user interface.\newline Usually
			consists of a visual component and a callback\\
			Callback & A method to be executed upon interaction with a widget\\
			Bijection & A one-to-one mapping of elements in one set to another\\
			\bottomrule
		\end{tabularx}
	\end{table}	
	\subsection{Overview of Document}
	\indent \indent This document provides a detailed description of the 
	testing our development team has deemed necessary for the software product. 
	The tests are categorized and subdivided based on the type of testing, the 
	scope of said categories, and the purpose and application of the tests (ie. 
	validating the fulfillment functional or non-functional requirements).\par
	This document is subject to revision throughout the expected life of the 
	product. It is not expected that many deletions or shrinking of the test 
	sets will occur; however, additional testing will likely be prescribed and 
	document as the product is developed and matures.
	
	\section{Plan}
	This section details the testing process prescribed for the software 
	product, including but not limited to the testing team, schedule, 
	techniques, and technologies.
	\subsection{Software Description}

	\subsection{Test Team}
	\begin{itemize}
		\itemsep0em
		\item Aravi Premachandran
		\item Michael Lee
		\item Nikhil Patel
	\end{itemize}
	\subsection{Automated Testing Approach}
	\indent \indent The testing team will be applying automated testing for a 
	subset of the structural and static tests. In particular, unit tests will 
	primarily be automated to increase reproducibility and efficiency, among 
	other factors. It should be noted that in automated testing, only the 
	execution and evaluation (of pre-defined criteria) is automated - in the 
	event of failures or unexpected behaviour a member of the testing team will 
	still be required to analyze the requirements, the code, and the test 
	itself to determine where the inconsistency, if any, is located.
	
	\subsection{Testing Tools}
	\begin{itemize}
		\itemsep0em
		\item IDE - PyCharm
		\vspace{-3mm}
		\begin{itemize}
			\item static, structural: syntax checking, reachability, adherence 
			to coding conventions
		\end{itemize}
		\item pylint / pyCheckers
		\vspace{-3mm}
		\begin{itemize}
			\item static, stuctural: syntax checking, reachability, adherence 
			to coding conventions
		\end{itemize}
		\item unittest.py - built-in module for testing
		\vspace{-3mm}
		\begin{itemize}
			\item dynamic, unit test
			\vspace{-2mm}
			\begin{itemize}
				\item mock module - can be used for stubs and drivers, to 
				isolate code
			\end{itemize}
		\end{itemize}
	\end{itemize}
		
	\subsection{Testing Schedule}
	
	See Gantt Chart at the following url ...
	\section{System Test Description}
	
	\subsection{Tests for Functional Requirements}
	\subsubsection{Event Handling}
	
	\paragraph{Key Bindings}
	\begin{enumerate}
		\item{KB1\\}
		Type: Functional, Dynamic, Manual
		
		Initial State: Application instance that is capturing user input
		
		Input: Keyboard press of one of COMMAND\_KEYS by user
		
		Output: Application perform the associated action from BOUND\_ACTIONS. 
		Please refer to \textbf{\autoref{keymap}} \nameref{keymap} for mapping of keys
		to actions
		
		How test will be performed: The application will be launched and once loaded,
		each bound key in COMMAND\_KEYS will be pressed and we will observe whether
		the correct action from BOUND\_ACTIONS executes
		
	\end{enumerate}
	\subsubsection{Widget Callbacks}
	\begin{enumerate}
		\item{WC1\\}
		Type: Functional, Dynamic, Manual
		
		Initial State: Menubar widget waiting for user interaction
		
		Input: User clicks on a label in the menu bar
		
		Output: If the user clicks or hovers on a cascading menu it will expand
		to show all contained submenu labels. If the user clicks on a menu label
		it will perform its associated callback function
		
		How test will be performed: With full knowledge of what behaviour should
		result from clicking any of the menu labels, the user will choose a random
		subset of labels to click, and compare the expected and actual behaviour of
		the application

		\item{WC2\\}
		Type: Functional, Dynamic, Manual
		
		Initial State: Toolbar widget waiting for user interaction
		
		Input: User clicks on a toolbar button
		
		Output: The application will execute the appropriate function based upon
		the toolbar button clicked. There is a bijection between the actions in
		BOUND\_ACTIONS and toolbar buttons
		
		How test will be performed: The application will be launched and once loaded,
		each bound key in COMMAND\_KEYS will be pressed and we will observe whether
		the correct action from BOUND\_ACTIONS executes

		\item{WC3\\}
		Type: Functional, Dynamic, Manual
		
		Initial State: Card widgets waiting for user click
		
		Input: Primary button click on card widget
		
		Output: If the card selection is valid (see Functional Klondike Requirements in 
		\href{https://gitlab.cas.mcmaster.ca/premaa/pysol/tree/master/Doc/SRS}
		{PyCards SRS} for selection constraints) the card is highlighted while the
		mouse button remains pressed and is redrawn to follow the cursor. If the card
		selection is invalid no visible changes are made to the window.
		
		How test will be performed: With a game in progress two cards will be clicked
		one 'valid' and the other an 'invalid' selection and we will observe to make
		sure only the 'valid' selection results in a card being highlighted	
	\end{enumerate}


	\subsection{Tests for Nonfunctional Requirements}
	\subsubsection{Interoperability}
	
	\paragraph{Operating System Compatibility}
	\begin{enumerate}
		\item{OSX\\}
		Type: Structural, Dynamic, Manual
		
		Initial State: Executable for program is on target machine running a
		standard install of OS X OSX\_VERSION.
		
		Input/Condition: User locates executable and launches program
		
		Output/Result: Either a successful launch or a message from Gatekeeper
		alerting user that program was created by an unidentified developer
		
		How test will be performed: Executable is launched via double clicking to
		test whether or not Gatekeeper feature will block normal launch. User will
		observe whether basic functionality such as input/output and rendering of
		application window are successful
		
		\item{OS2\\}
		Type: Structural, Dynamic, Manual
		
		Initial State: Executable for program is on target machine running a
		standard install of Ubuntu UBUNTU\_VERSION.
		
		Input/Condition: User locates executable and launches program
		
		Output/Result: Either a successful launch or a failure caused by incompatible
		packaging, dependencies, or other causes
		
		How test will be performed: Executable is located and then launched via
		terminal on the target system. User will observe whether basic
		functionality such as input/output and rendering of application window are
		successful

		\item{OSWIN\\}
		Type: Structural, Dynamic, Manual
		
		Initial State: Executable for program is on target machine running a
		standard install of Windows WIN\_VERSION.
		
		Input/Condition: User locates executable and launches program via double-click
		
		Output/Result: Depending on the system, either a successful launch or
		application crash due to missing VC++2008 binaries (required even after 
		building executable)
		
		How test will be performed: Executable is located and then launched via
		double-click on the target system. User will observe whether basic
		functionality such as input/output and rendering of application window are
		successful


	\end{enumerate}

	\paragraph{Portability}
	\begin{enumerate}
		\item{PR1\\}
		Type: Structural, Dynamic, Manual
		
		Initial State: Executable for application is located on a removable USB drive
		
		Input/Condition: User launches program executable from a removable USB drive
		
		Output/Result: The program launches exactly as if it had been launched on
		the same system from the internal hard drive.
		
		How test will be performed: User inserts removable drive into a machine running a
		supported OS then executes the executable either via double-clicking or using
		a shell (ie. bash, command-line). User will observe whether or not the program
		successfuly launches and operates
	\end{enumerate}

	\subsubsection{Usability}
	\paragraph{Navigation}
	\begin{enumerate}
		\item{UN1\\}
		Type: 
		
		Initial State: 
		
		Input/Condition: 
		
		Output/Result: 
		
		How test will be performed: 
		
		\item{UN2\\}
		Type: Functional, Dynamic, Manual, Static etc.
		
		Initial State: 
		
		Input: 
		
		Output: 
		
		How test will be performed: 
	\end{enumerate}

	\subsubsection{Product Integrity}
	\paragraph{Resource Loading}
	\begin{enumerate}
		\item{RL1\\}
		Type: 
		
		Initial State: 
		
		Input/Condition: 
		
		Output/Result: 
		
		How test will be performed: 
		
		\item{RL2\\}
		Type: Functional, Dynamic, Manual, Static etc.
		
		Initial State: 
		
		Input: 
		
		Output: 
		
		How test will be performed: 
	\end{enumerate}
	
	\subsubsection{Security}
	\paragraph{System Permissions}
	\begin{enumerate}
		\item{SP1\\}
		Type: 
		
		Initial State: 
		
		Input/Condition: 
		
		Output/Result: 
		
		How test will be performed: 
		
		\item{SP2\\}
		Type: Functional, Dynamic, Manual, Static etc.
		
		Initial State: 
		
		Input: 
		
		Output: 
		
		How test will be performed: 
	\end{enumerate}

	\section{Tests for Proof of Concept}
	\subsection{Area of Testing1}
	
	\paragraph{Title for Test}
	\begin{enumerate}
		\item{PC1\\}
		Type: Functional, Dynamic, Manual, Static etc.
		
		Initial State: 
		
		Input: 
		
		Output: 
		
		How test will be performed: 
		
		\item{PC2\\}
		Type: Functional, Dynamic, Manual, Static etc.
		
		Initial State: 
		
		Input: 
		
		Output: 
		
		How test will be performed: 
	\end{enumerate}
	\subsection{Area of Testing2}
	...
	
	\section{Comparison to Existing Implementation}	
	
	\section{Unit Testing Plan}
	
	\subsection{Unit testing of internal functions}
	
	\subsection{Unit testing of output files}		
	\bibliographystyle{plainnat}
	\bibliography{TestPlan}
	\newpage
	\section{Appendix}

	\subsection{Symbolic Parameters}
	\begin{itemize}
			\itemsep0em
			\item COMMAND\_KEYS = \{'N', 'P', 'U', 'R', 'D', 'H', \newline 'F1', 'F2', CTRL+N,
			CTRL+P, CTRL+'\}
			\item BOUND\_ACTIONS = \{newgame, pause, undo, redo, deal, help, quit\}
			\item NUM\_REDEALS = Unlimited
			\item FOUNDATION\_BASE = Ace
			\item STACK\_BASE = King
			\item NUM\_DECKS = 1
			\item NUM\_WASTES = 1
			\item NUM\_FOUNDATIONS = NUM\_SUITS = 4
			\item NUM\_NORMAL\_STACKS = 7
			\item OSX\_VERSION = EL\_CAPITAN
			\item UBUNTU\_VERSION = 16.04.1
			\item WIN\_VERSION = 10
	\end{itemize}

	\subsection{Reference Tables}
	\begin{table}[hbp]
		\caption{\textbf{Keymapping Configurations}} \label{keymap}
		\begin{tabularx}{\textwidth}{p{6cm}X}
			\toprule
			\textbf{COMMAND\_KEYS} & \textbf{BOUND\_ACTIONS} \\
			\midrule
			'CTRL+N', 'N', 'F2' & new\_game\\
			'CTRL+P', 'P' & pause\_game\\
			'CTRL+Q', 'Q' & quit\\
			'CTRL+H', 'H', 'F1' & show\_help\\
			'U' & undo\_move\\
			'R' & redo\_move\\
			'D' & deal\_card\\
			\bottomrule
		\end{tabularx}
	\end{table}

	\subsection{Usability Survey Questions?}
	This is a section that would be appropriate for some teams.
\end{document}